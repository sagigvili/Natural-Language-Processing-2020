C ( , as in the letter c ) is a , procedural computer programming language supporting structured programming , lexical variable scope , and recursion , with a static type system .
By design , C provides constructs that map efficiently to typical machine instructions .
It has found lasting use in applications previously coded in assembly language .
Such applications include operating systems and various application software for computer architectures that range from supercomputers to PLCs and embedded systems .
A successor to the programming language B , C was originally developed at Bell Labs by Dennis Ritchie between 1972 and 1973 to construct utilities running on Unix .
It was applied to the kernel of the Unix operating system .
During the 1980s , C gradually gained popularity .
It has become one of the most widely used programming languages , with C compilers from various vendors available for the majority of existing computer architectures and operating systems .
C has been standardized by the ANSI since 1989 ( ANSI C ) and by the International Organization for Standardization ( ISO ) .
As of September 2020 , C is the most popular programming is an imperative procedural language .
It was designed to be compiled to provide access to memory and language constructs that map efficiently to machine instructions , all with minimal runtime support .
Despite its capabilities , the language was designed to encourage programming .
A C program written with portability in mind can be compiled for a wide variety of computer platforms and operating systems with few changes to its source code .
== Overview ==
Like most procedural languages in the ALGOL tradition , C has facilities for structured programming and allows lexical variable scope and recursion .
Its static type system prevents unintended operations .
In C , all executable code is contained within subroutines ( also called functions , though not strictly in the sense of functional programming ) .
Function parameters are always passed by value .
is simulated in C by explicitly passing pointer values .
C program source text is , using the semicolon as a statement terminator and curly braces for grouping blocks of statements .
The C language also exhibits the following characteristics : The language has a small , fixed number of keywords , including a full set of control flow primitives : , for , , while , and switch .
names are not distinguished from keywords by any kind of sigil .
It has a large number of arithmetic , bitwise , and logic operators : , , , , , etc .
More than one assignment may be performed in a single statement .
Functions : Function return values can be ignored , when not needed .
Function and data pointers permit ad hoc polymorphism .
Functions may not be defined within the lexical scope of other functions .
Data typing is static , but weakly enforced ; all data has a type , but implicit conversions are possible .
Declaration syntax mimics usage context .
C has no define keyword ; instead , a statement beginning with the name of a type is taken as a declaration .
There is no function keyword ; instead , a function is indicated by the presence of a parenthesized argument list .
( typedef ) and compound types are possible .
Heterogeneous aggregate data types ( struct ) allow related data elements to be accessed and assigned as a unit .
Union is a structure with overlapping members ; only the last member stored is valid .
Array indexing is a secondary notation , defined in terms of pointer arithmetic .
Unlike structs , arrays are not objects : they can not be assigned or compared using single operators .
There is no array keyword in use or definition ; instead , square brackets indicate arrays syntactically , for example month [ 11 ] .
Enumerated types are possible with the enum keyword .
They are freely interconvertible with integers .
Strings are not a distinct data type , but are conventionally implemented as character arrays .
access to computer memory is possible by converting machine addresses to typed pointers .
Procedures ( subroutines not returning values ) are a special case of function , with an untyped return type void .
A preprocessor performs macro definition , source code file inclusion , and conditional compilation .
There is a basic form of modularity : files can be compiled separately and linked together , with control over which functions and data objects are visible to other files via static and extern attributes .
Complex functionality such as , string manipulation , and mathematical functions are consistently delegated to library C does not include certain features found in other languages ( such as object orientation and garbage collection ) , these can be implemented or emulated , often through the use of external libraries ( , the GLib Object System or the Boehm garbage collector ) .
=== Relations to other languages ===
Many later languages have borrowed directly or indirectly from C , including , C , Unix C shell , D , Go , Java , JavaScript ( including transpilers ) , Julia , Limbo , LPC , , Perl , PHP , Python , Rust , Swift , Verilog and SystemVerilog ( hardware description languages ) .
These languages have drawn many of their control structures and other basic features from Most of them ( Python being a dramatic exception ) also express highly similar syntax to C , and they tend to combine the recognizable expression and statement syntax of C with underlying type systems , data models , and semantics that can be radically different .
== History ==
=== Early developments ===
The origin of C is closely tied to the development of the Unix operating system , originally implemented in assembly language on a by Dennis Ritchie and Ken Thompson , incorporating several ideas from colleagues .
Eventually , they decided to port the operating system to a .
The original version of Unix was also developed in assembly desired a programming language to make utilities for the new platform .
At first , he tried to make a Fortran compiler , but soon gave up the idea .
Instead , he created a version of the recently developed BCPL systems programming language .
The official description of BCPL was not available at the time , and Thompson modified the syntax to be less wordy , producing the similar but somewhat simpler B .
However , few utilities were ultimately written in B because it was too slow , and B could not take advantage of features such as byte addressability .
In 1972 , Ritchie started to improve B , which resulted in creating a new language The C compiler and some utilities made with it were included in Version 2 Version 4 Unix , released in November 1973 , the Unix kernel was extensively in By this time , the C language had acquired some powerful features such as struct types .
Preprocessor was introduced around 1973 at the urging of Alan Snyder and also in recognition of the usefulness of the mechanisms available in BCPL and .
Its original version provided only included files and simple string replacements : include and define of parameterless macros .
Soon after that , it was extended , mostly by Mike Lesk and then by John Reiser , to incorporate macros with arguments and conditional was one of the first operating system kernels implemented in a language other than assembly .
Earlier instances include the Multics system ( which was written in ) and Master Control Program ( MCP ) for the Burroughs B5000 ( which was written in ALGOL ) in 1961 .
In around 1977 , Ritchie and Stephen Johnson made further changes to the language to facilitate portability of the Unix operating system .
Johnson Portable C Compiler served as the basis for several implementations of C on new platforms .
=== K R C ===
In 1978 , Brian Kernighan and Dennis Ritchie published the first edition of The C Programming Language .
This book , known to C programmers as K R , served for many years as an informal specification of the language .
The version of C that it describes is commonly referred to as K R C .
The second edition of the book covers the later ANSI C standard , described below .
K R introduced several language features : Standard library long int data type unsigned int data type Compound assignment operators of the form ( such as ) were changed to the form ( that is , ) to remove the semantic ambiguity created by constructs such as , which had been interpreted as i 10 ( decrement i by 10 ) instead of the possibly intended i = ( let i be ) after the publication of the 1989 ANSI standard , for many years K R C was still considered the lowest common denominator to which C programmers restricted themselves when maximum portability was desired , since many older compilers were still in use , and because carefully written K R C code can be legal Standard C as well .
In early versions of C , only functions that return types other than int must be declared if used before the function definition ; functions used without prior declaration were presumed to return type int .
For example : The int type specifiers which are commented out could be omitted in K R C , but are required in later standards .
Since K R function declarations did not include any information about function arguments , function parameter type checks were not performed , although some compilers would issue a warning message if a local function was called with the wrong number of arguments , or if multiple calls to an external function used different numbers or types of arguments .
Separate tools such as Unix lint utility were developed that ( among other things ) could check for consistency of function use across multiple source files .
In the years following the publication of K R C , several features were added to the language , supported by compilers from AT T ( in particular PCC ) and some other vendors .
These included : void functions ( , functions with no return value ) functions returning struct or union types ( rather than pointers ) assignment for struct data types enumerated typesThe large number of extensions and lack of agreement on a standard library , together with the language popularity and the fact that not even the Unix compilers precisely implemented the K R specification , led to the necessity of standardization .
=== ANSI C and ISO C ===
During the late 1970s and 1980s , versions of C were implemented for a wide variety of mainframe computers , minicomputers , and microcomputers , including the IBM PC , as its popularity began to increase significantly .
In 1983 , the American National Standards Institute ( ANSI ) formed a committee , X3J11 , to establish a standard specification of X3J11 based the C standard on the Unix implementation ; however , the portion of the Unix C library was handed off to the IEEE working group 1003 to become the basis for the 1988 POSIX standard .
In 1989 , the C standard was ratified as ANSI Programming Language C .
This version of the language is often referred to as ANSI C , Standard C , or sometimes C89 .
In 1990 , the ANSI C standard ( with formatting changes ) was adopted by the International Organization for Standardization ( ISO ) as , which is sometimes called C90 .
Therefore , the terms C89 and C90 refer to the same programming language .
ANSI , like other national standards bodies , no longer develops the C standard independently , but defers to the international C standard , maintained by the working group .
National adoption of an update to the international standard typically occurs within a year of ISO publication .
One of the aims of the C standardization process was to produce a superset of K R C , incorporating many of the subsequently introduced unofficial features .
The standards committee also included several additional features such as function prototypes ( borrowed from ) , void pointers , support for international character sets and locales , and preprocessor enhancements .
Although the syntax for parameter declarations was augmented to include the style used in , the K R interface continued to be permitted , for compatibility with existing source code .
C89 is supported by current C compilers , and most modern C code is based on it .
Any program written only in Standard C and without any assumptions will run correctly on any platform with a conforming C implementation , within its resource limits .
Without such precautions , programs may compile only on a certain platform or with a particular compiler , due , for example , to the use of libraries , such as GUI libraries , or to a reliance on or attributes such as the exact size of data types and byte endianness .
In cases where code must be compilable by either or K R compilers , the macro can be used to split the code into Standard and K R sections to prevent the use on a K R compiler of features available only in Standard After the standardization process , the C language specification remained relatively static for several years .
In 1995 , Normative Amendment 1 to the 1990 C standard ( , known informally as C95 ) was published , to correct some details and to add more extensive support for international character sets .
=== C99 ===
The C standard was further revised in the late 1990s , leading to the publication of in 1999 , which is commonly referred to as C99 .
It has since been amended three times by Technical introduced several new features , including inline functions , several new data types ( including long long int and a complex type to represent complex numbers ) , arrays and flexible array members , improved support for IEEE 754 floating point , support for variadic macros ( macros of variable arity ) , and support for comments beginning with , as in BCPL or .
Many of these had already been implemented as extensions in several C compilers .
C99 is for the most part backward compatible with C90 , but is stricter in some ways ; in particular , a declaration that lacks a type specifier no longer has int implicitly assumed .
A standard macro is defined with value 199901L to indicate that C99 support is available .
GCC , Solaris Studio , and other C compilers now support many or all of the new features of C99 .
The C compiler in Microsoft Visual , however , implements the C89 standard and those parts of C99 that are required for compatibility with addition , support for Unicode identifiers ( variable function names ) in the form of escaped characters ( .
) is now required .
Support for raw Unicode names like is optional .
=== C11 ===
In 2007 , work began on another revision of the C standard , informally called C1X until its official publication on .
The C standards committee adopted guidelines to limit the adoption of new features that had not been tested by existing implementations .
The C11 standard adds numerous new features to C and the library , including type generic macros , anonymous structures , improved Unicode support , atomic operations , , and functions .
It also makes some portions of the existing C99 library optional , and improves compatibility with .
The standard macro is defined as 201112L to indicate that C11 support is available .
=== C17 ===
Published in June 2018 , C17 is the current standard for the C programming language .
It introduces no new language features , only technical corrections , and clarifications to defects in C11 .
The standard macro is defined as 201710L .
=== C2x ===
C2x is an informal name for the next ( after C17 ) major C language standard revision .
It is not expected to be voted on until 2021 .
=== Embedded C ===
Historically , embedded C programming requires nonstandard extensions to the C language in order to support exotic features such as arithmetic , multiple distinct memory banks , and basic operations .
In 2008 , the C Standards Committee published a technical report extending the C language to address these issues by providing a common standard for all implementations to adhere to .
It includes a number of features not available in normal C , such as arithmetic , named address spaces , and basic hardware addressing .
== Syntax ==
C has a formal grammar specified by the C standard .
Line endings are generally not significant in C ; however , line boundaries do have significance during the preprocessing phase .
Comments may appear either between the delimiters and , or ( since C99 ) following until the end of the line .
Comments delimited by and do not nest , and these sequences of characters are not interpreted as comment delimiters if they appear inside string or character source files contain declarations and function definitions .
Function definitions , in turn , contain declarations and statements .
Declarations either define new types using keywords such as struct , union , and enum , or assign types to and perhaps reserve storage for new variables , usually by writing the type followed by the variable name .
Keywords such as char and int specify types .
Sections of code are enclosed in braces ( and , sometimes called curly brackets ) to limit the scope of declarations and to act as a single statement for control structures .
As an imperative language , C uses statements to specify actions .
The most common statement is an expression statement , consisting of an expression to be evaluated , followed by a semicolon ; as a side effect of the evaluation , functions may be called and variables may be assigned new values .
To modify the normal sequential execution of statements , C provides several statements identified by reserved keywords .
Structured programming is supported by if conditional execution and by , while , and for iterative execution ( looping ) .
The for statement has separate initialization , testing , and reinitialization expressions , any or all of which can be omitted .
break and continue can be used to leave the innermost enclosing loop statement or skip to its reinitialization .
There is also a goto statement which branches directly to the designated label within the function .
switch selects a case to be executed based on the value of an integer expression .
Expressions can use a variety of operators and may contain function calls .
The order in which arguments to functions and operands to most operators are evaluated is unspecified .
The evaluations may even be interleaved .
However , all side effects ( including storage to variables ) will occur before the next sequence point ; sequence points include the end of each expression statement , and the entry to and return from each function call .
Sequence points also occur during evaluation of expressions containing certain operators ( , ,
: and the comma operator ) .
This permits a high degree of object code optimization by the compiler , but requires C programmers to take more care to obtain reliable results than is needed for other programming languages .
Kernighan and Ritchie say in the Introduction of The C Programming Language : C , like any other language , has its blemishes .
Some of the operators have the wrong precedence ; some parts of the syntax could be better .
The C standard did not attempt to correct many of these blemishes , because of the impact of such changes on already existing software .
=== Character set ===
The basic C source character set includes the following characters : Lowercase and uppercase letters of ISO Basic Latin Alphabet : Decimal digits : Graphic characters :
, - .
: ; =
[ ] Whitespace characters : space , horizontal tab , vertical tab , form feed , newlineNewline indicates the end of a text line ; it need not correspond to an actual single character , although for convenience C treats it as one .
Additional encoded characters may be used in string literals , but they are not entirely portable .
The latest C standard ( C11 ) allows Unicode characters to be embedded portably within C source text by using or encoding ( where the X denotes a hexadecimal character ) , although this feature is not yet widely implemented .
The basic C execution character set contains the same characters , along with representations for alert , backspace , and carriage return .
support for extended character sets has increased with each revision of the C standard .
=== Reserved words ===
C89 has 32 reserved words , also known as keywords , which are the words that can not be used for any purposes other than those for which they are predefined : C99 reserved five more words : C11 reserved seven more words : Most of the recently reserved words begin with an underscore followed by a capital letter , because identifiers of that form were previously reserved by the C standard for use only by implementations .
Since existing program source code should not have been using these identifiers , it would not be affected when C implementations started supporting these extensions to the programming language .
Some standard headers do define more convenient synonyms for underscored identifiers .
The language previously included a reserved word called entry , but this was seldom implemented , and has now been removed as a reserved word .
=== Operators ===
C supports a rich set of operators , which are symbols used within an expression to specify the manipulations to be performed while evaluating that expression .
C has operators for : arithmetic : , - , , , assignment : = augmented assignment : , , = , , = , = , , , = , = bitwise logic : , , , bitwise shifts : , boolean logic : , , conditional evaluation :
: equality testing : == , = calling functions : increment and decrement : , member selection : . , - object size : sizeof order relations : , = , , = reference and dereference : , , [ ] sequencing : , subexpression grouping : type conversion : ( typename ) C uses the operator = ( used in mathematics to express equality ) to indicate assignment , following the precedent of Fortran and , but unlike ALGOL and its derivatives .
C uses the operator == to test for equality .
The similarity between these two operators ( assignment and equality ) may result in the accidental use of one in place of the other , and in many cases , the mistake does not produce an error message ( although some compilers produce warnings ) .
For example , the conditional expression if ( a == b 1 ) might mistakenly be written as if ( a = b 1 ) , which will be evaluated as true if a is not zero after the C operator precedence is not always intuitive .
For example , the operator == binds more tightly than ( is executed prior to ) the operators ( bitwise AND ) and ( bitwise OR ) in expressions such as x 1 == 0 , which must be written as ( x 1 ) == 0 if that is the coder intent .
== Hello , world example == The hello , world example , which appeared in the first edition of K R , has become the model for an introductory program in most programming textbooks .
The program prints hello , world to the standard output , which is usually a terminal or screen display .
The original version was : A hello , world program is : The first line of the program contains a preprocessing directive , indicated by include .
This causes the compiler to replace that line with the entire text of the standard header , which contains declarations for standard input and output functions such as printf and scanf .
The angle brackets surrounding indicate that is located using a search strategy that prefers headers provided with the compiler to other headers having the same name , as opposed to double quotes which typically include local or header files .
The next line indicates that a function named main is being defined .
The main function serves a special purpose in C programs ; the environment calls the main function to begin program execution .
The type specifier int indicates that the value that is returned to the invoker ( in this case the environment ) as a result of evaluating the main function , is an integer .
The keyword void as a parameter list indicates that this function takes no opening curly brace indicates the beginning of the definition of the main function .
The next line calls ( diverts execution to ) a function named printf , which in this case is supplied from a system library .
In this call , the printf function is passed ( provided with ) a single argument , the address of the first character in the string literal hello , .
The string literal is an unnamed array with elements of type char , set up automatically by the compiler with a final character to mark the end of the array ( printf needs to know this ) .
The is an escape sequence that C translates to a newline character , which on output signifies the end of the current line .
The return value of the printf function is of type int , but it is silently discarded since it is not used .
( A more careful program might test the return value to determine whether or not the printf function succeeded . )
The semicolon ; terminates the statement .
The closing curly brace indicates the end of the code for the main function .
According to the C99 specification and newer , the main function , unlike any other function , will implicitly return a value of 0 upon reaching the that terminates the function .
( Formerly an explicit return 0 ; statement was required . )
This is interpreted by the system as an exit code indicating successful execution .
== Data types ==
The type system in C is static and weakly typed , which makes it similar to the type system of ALGOL descendants such as Pascal .
There are types for integers of various sizes , both signed and unsigned , numbers , and enumerated types ( enum ) .
Integer type char is often used for characters .
C99 added a boolean datatype .
There are also derived types including arrays , pointers , records ( struct ) , and unions ( union ) .
C is often used in systems programming where escapes from the type system may be necessary .
The compiler attempts to ensure type correctness of most expressions , but the programmer can override the checks in various ways , either by using a type cast to explicitly convert a value from one type to another , or by using pointers or unions to reinterpret the underlying bits of a data object in some other way .
Some find C declaration syntax unintuitive , particularly for function pointers .
( Ritchie idea was to declare identifiers in contexts resembling their use : declaration reflects use .
) C usual arithmetic conversions allow for efficient code to be generated , but can sometimes produce unexpected results .
For example , a comparison of signed and unsigned integers of equal width requires a conversion of the signed value to unsigned .
This can generate unexpected results if the signed value is negative .
=== Pointers ===
C supports the use of pointers , a type of reference that records the address or location of an object or function in memory .
Pointers can be dereferenced to access data stored at the address pointed to , or to invoke a function .
Pointers can be manipulated using assignment or pointer arithmetic .
The representation of a pointer value is typically a raw memory address ( perhaps augmented by an field ) , but since a pointer type includes the type of the thing pointed to , expressions including pointers can be at compile time .
Pointer arithmetic is automatically scaled by the size of the data type .
Pointers are used for many purposes in Text strings are commonly manipulated using pointers into arrays of characters .
Dynamic memory allocation is performed using pointers .
Many data types , such as trees , are commonly implemented as dynamically allocated struct objects linked together using pointers .
Pointers to functions are useful for passing functions as arguments to functions ( such as qsort or bsearch ) or as callbacks to be invoked by event null pointer value explicitly points to no valid location .
Dereferencing a null pointer value is undefined , often resulting in a segmentation fault .
Null pointer values are useful for indicating special cases such as no next pointer in the final node of a linked list , or as an error indication from functions returning pointers .
In appropriate contexts in source code , such as for assigning to a pointer variable , a null pointer constant can be written as 0 , with or without explicit casting to a pointer type , or as the NULL macro defined by several standard headers .
In conditional contexts , null pointer values evaluate to false , while all other pointer values evaluate to true .
Void pointers ( void ) point to objects of unspecified type , and can therefore be used as generic data pointers .
Since the size and type of the object is not known , void pointers can not be dereferenced , nor is pointer arithmetic on them allowed , although they can easily be ( and in many contexts implicitly are ) converted to and from any other object pointer use of pointers is potentially dangerous .
Because they are typically unchecked , a pointer variable can be made to point to any arbitrary location , which can cause undesirable effects .
Although properly used pointers point to safe places , they can be made to point to unsafe places by using invalid pointer arithmetic ; the objects they point to may continue to be used after deallocation ( dangling pointers ) ; they may be used without having been initialized ( wild pointers ) ; or they may be directly assigned an unsafe value using a cast , union , or through another corrupt pointer .
In general , C is permissive in allowing manipulation of and conversion between pointer types , although compilers typically provide options for various levels of checking .
Some other programming languages address these problems by using more restrictive reference types .
=== Arrays ===
Array types in C are traditionally of a fixed , static size specified at compile time .
( The more recent C99 standard also allows a form of arrays . )
However , it is also possible to allocate a block of memory ( of arbitrary size ) at , using the standard library malloc function , and treat it as an array .
C unification of arrays and pointers means that declared arrays and these dynamically allocated simulated arrays are virtually interchangeable .
Since arrays are always accessed ( in effect ) via pointers , array accesses are typically not checked against the underlying array size , although some compilers may provide bounds checking as an option .
Array bounds violations are therefore possible and rather common in carelessly written code , and can lead to various repercussions , including illegal memory accesses , corruption of data , buffer overruns , and exceptions .
If bounds checking is desired , it must be done manually .
C does not have a special provision for declaring arrays , but rather relies on recursion within the type system to declare arrays of arrays , which effectively accomplishes the same thing .
The index values of the resulting array can be thought of as increasing in order .
arrays are commonly used in numerical algorithms ( mainly from applied linear algebra ) to store matrices .
The structure of the C array is well suited to this particular task .
However , since arrays are passed merely as pointers , the bounds of the array must be known fixed values or else explicitly passed to any subroutine that requires them , and dynamically sized arrays of arrays can not be accessed using double indexing .
( A workaround for this is to allocate the array with an additional row vector of pointers to the columns . )
C99 introduced arrays which address some , but not all , of the issues with ordinary C arrays .
=== interchangeability ===
The subscript notation x [ i ] ( where x designates a pointer ) is syntactic sugar for .
Taking advantage of the compiler knowledge of the pointer type , the address that x i points to is not the base address ( pointed to by x ) incremented by i bytes , but rather is defined to be the base address incremented by i multiplied by the size of an element that x points to .
Thus , x [ i ] designates the element of the array .
Furthermore , in most expression contexts ( a notable exception is as operand of sizeof ) , the name of an array is automatically converted to a pointer to the array first element .
This implies that an array is never copied as a whole when named as an argument to a function , but rather only the address of its first element is passed .
Therefore , although function calls in C use semantics , arrays are in effect passed by reference .
The size of an element can be determined by applying the operator sizeof to any dereferenced element of x , as in n = sizeof x or n = sizeof x [ 0 ] , and the number of elements in a declared array A can be determined as sizeof A sizeof A [ 0 ] .
The latter only applies to array names : variables declared with subscripts ( int A [ 20 ] ) .
Due to the semantics of C , it is not possible to determine the entire size of arrays through pointers to arrays or those created by dynamic allocation ( malloc ) ; code such as sizeof arr sizeof arr [ 0 ] ( where arr designates a pointer ) will not work since the compiler assumes the size of the pointer itself is being requested .
Since array name arguments to sizeof are not converted to pointers , they do not exhibit such ambiguity .
However , arrays created by dynamic allocation are accessed by pointers rather than true array variables , so they suffer from the same sizeof issues as array pointers .
Thus , despite this apparent equivalence between array and pointer variables , there is still a distinction to be made between them .
Even though the name of an array is , in most expression contexts , converted into a pointer ( to its first element ) , this pointer does not itself occupy any storage ; the array name is not an , and its address is a constant , unlike a pointer variable .
Consequently , what an array points to can not be changed , and it is impossible to assign a new address to an array name .
Array contents may be copied , however , by using the memcpy function , or by accessing the individual elements .
== Memory management ==
One of the most important functions of a programming language is to provide facilities for managing memory and the objects that are stored in memory .
C provides three distinct ways to allocate memory for objects : Static memory allocation : space for the object is provided in the binary at ; these objects have an extent ( or lifetime ) as long as the binary which contains them is loaded into memory .
Automatic memory allocation : temporary objects can be stored on the stack , and this space is automatically freed and reusable after the block in which they are declared is exited .
Dynamic memory allocation : blocks of memory of arbitrary size can be requested at using library functions such as malloc from a region of memory called the heap ; these blocks persist until subsequently freed for reuse by calling the library function realloc or freeThese three approaches are appropriate in different situations and have various .
For example , static memory allocation has little allocation overhead , automatic allocation may involve slightly more overhead , and dynamic memory allocation can potentially have a great deal of overhead for both allocation and deallocation .
The persistent nature of static objects is useful for maintaining state information across function calls , automatic allocation is easy to use but stack space is typically much more limited and transient than either static memory or heap space , and dynamic memory allocation allows convenient allocation of objects whose size is known only at .
Most C programs make extensive use of all three .
Where possible , automatic or static allocation is usually simplest because the storage is managed by the compiler , freeing the programmer of the potentially chore of manually allocating and releasing storage .
However , many data structures can change in size at runtime , and since static allocations ( and automatic allocations before C99 ) must have a fixed size at , there are many situations in which dynamic allocation is necessary .
Prior to the C99 standard , arrays were a common example of this .
( See the article on malloc for an example of dynamically allocated arrays . )
Unlike automatic allocation , which can fail at run time with uncontrolled consequences , the dynamic allocation functions return an indication ( in the form of a null pointer value ) when the required storage can not be allocated .
( Static allocation that is too large is usually detected by the linker or loader , before the program can even begin execution . )
Unless otherwise specified , static objects contain zero or null pointer values upon program startup .
Automatically and dynamically allocated objects are initialized only if an initial value is explicitly specified ; otherwise they initially have indeterminate values ( typically , whatever bit pattern happens to be present in the storage , which might not even represent a valid value for that type ) .
If the program attempts to access an uninitialized value , the results are undefined .
Many modern compilers try to detect and warn about this problem , but both false positives and false negatives can occur .
Another issue is that heap memory allocation has to be synchronized with its actual usage in any program in order for it to be reused as much as possible .
For example , if the only pointer to a heap memory allocation goes out of scope or has its value overwritten before free is called , then that memory can not be recovered for later reuse and is essentially lost to the program , a phenomenon known as a memory leak .
Conversely , it is possible for memory to be freed but continue to be referenced , leading to unpredictable results .
Typically , the symptoms will appear in a portion of the program far removed from the actual error , making it difficult to track down the problem .
( Such issues are ameliorated in languages with automatic garbage collection . )
== Libraries ==
The C programming language uses libraries as its primary method of extension .
In C , a library is a set of functions contained within a single archive file .
Each library typically has a header file , which contains the prototypes of the functions contained within the library that may be used by a program , and declarations of special data types and macro symbols used with these functions .
In order for a program to use a library , it must include the library header file , and the library must be linked with the program , which in many cases requires compiler flags ( , , shorthand for link the math library ) most common C library is the C standard library , which is specified by the ISO and ANSI C standards and comes with every C implementation ( implementations which target limited environments such as embedded systems may provide only a subset of the standard library ) .
This library supports stream input and output , memory allocation , mathematics , character strings , and time values .
Several separate standard headers ( for example , ) specify the interfaces for these and other standard library facilities .
Another common set of C library functions are those used by applications specifically targeted for Unix and systems , especially functions which provide an interface to the kernel .
These functions are detailed in various standards such as POSIX and the Single UNIX Specification .
Since many programs have been written in C , there are a wide variety of other libraries available .
Libraries are often written in C because C compilers generate efficient object code ; programmers then create interfaces to the library so that the routines can be used from languages like Java , Perl , and Python .
=== File handling and streams ===
File input and output is not part of the C language itself but instead is handled by libraries ( such as the C standard library ) and their associated header files ( .
) .
File handling is generally implemented through which works through streams .
A stream is from this perspective a data flow that is independent of devices , while a file is a concrete device .
The high level is done through the association of a stream to a file .
In the C standard library , a buffer ( a memory area or queue ) is temporarily used to store data before it sent to the final destination .
This reduces the time spent waiting for slower devices , for example a hard drive or solid state drive .
functions are not part of the standard C library but are generally part of bare metal programming ( programming that independent of any operating system such as most but not all embedded programming ) .
With few exceptions , implementations include .
== Language tools ==
A number of tools have been developed to help C programmers find and fix statements with undefined behavior or possibly erroneous expressions , with greater rigor than that provided by the compiler .
The tool lint was the first such , leading to many others .
Automated source code checking and auditing are beneficial in any language , and for C many such tools exist , such as Lint .
A common practice is to use Lint to detect questionable code when a program is first written .
Once a program passes Lint , it is then compiled using the C compiler .
Also , many compilers can optionally warn about syntactically valid constructs that are likely to actually be errors .
MISRA C is a proprietary set of guidelines to avoid such questionable code , developed for embedded are also compilers , libraries , and operating system level mechanisms for performing actions that are not a standard part of C , such as bounds checking for arrays , detection of buffer overflow , serialization , dynamic memory tracking , and automatic garbage collection .
Tools such as Purify or Valgrind and linking with libraries containing special versions of the memory allocation functions can help uncover runtime errors in memory usage .
== Uses ==
C is widely used for systems programming in implementing operating systems and embedded system applications , because C code , when written for portability , can be used for most purposes , yet when needed , code can be used to access specific hardware addresses and to perform type punning to match externally imposed interface requirements , with a low demand on system resources .
C can be used for website programming using the Common Gateway Interface ( CGI ) as a gateway for information between the Web application , the server , and the browser .
C is often chosen over interpreted languages because of its speed , stability , and consequence of C wide availability and efficiency is that compilers , libraries and interpreters of other programming languages are often implemented in For example , the reference implementations of Python , Perl , and PHP are written in C enables programmers to create efficient implementations of algorithms and data structures , because the layer of abstraction from hardware is thin , and its overhead is low , an important criterion for computationally intensive programs .
For example , the GNU Multiple Precision Arithmetic Library , the GNU Scientific Library , Mathematica , and MATLAB are completely or partially written in C is sometimes used as an intermediate language by implementations of other languages .
This approach may be used for portability or convenience ; by using C as an intermediate language , additional code generators are not necessary .
C has some features , such as preprocessor directives and optional superfluous commas at the end of initializer lists , that support compilation of generated code .
However , some of C shortcomings have prompted the development of other languages specifically designed for use as intermediate languages , such as C .
C has also been widely used to implement applications .
However , such applications can also be written in newer , languages .
== Related languages ==
C has both directly and indirectly influenced many later languages such as C , D , Go , Java , JavaScript , Limbo , LPC , Perl , PHP , Python , and Unix C shell .
The most pervasive influence has been syntactical ; all of the languages mentioned combine the statement and ( more or less recognizably ) expression syntax of C with type systems , data models , program structures that differ from those of C , sometimes radically .
Several C or interpreters exist , including Ch and CINT , which can also be used for scripting .
When languages became popular , and were two different extensions of C that provided capabilities .
Both languages were originally implemented as compilers ; source code was translated into C , and then compiled with a C programming language was devised by Bjarne Stroustrup as an approach to providing functionality with a syntax .
adds greater typing strength , scoping , and other tools useful in programming , and permits generic programming via templates .
Nearly a superset of C , now supports most of C , with a few exceptions .
was originally a very thin layer on top of C , and remains a strict superset of C that permits programming using a hybrid typing paradigm .
derives its syntax from both C and Smalltalk : syntax that involves preprocessing , expressions , function declarations , and function calls is inherited from C , while the syntax for features was originally taken from Smalltalk .
In addition to and , Ch , Cilk , and Unified Parallel C are nearly supersets of == See also ==
Compatibility of C and Comparison of Pascal and C Comparison of programming languages International Obfuscated C Code Contest List of programming languages List of C compilers == Notes ==
== References ==
== Sources ==
Ritchie , Dennis ( March 1993 ) .
The Development of the C Language .
ACM SIGPLAN Notices .
ACM .
28 ( 3 ) : .
, Dennis ( 1993 ) .
The Development of the C Language .
The Second ACM SIGPLAN Conference on History of Programming Languages .
ACM .
pp .
ISBN .
Retrieved November 4 , 2014 .
Kernighan , Brian ; Ritchie , Dennis ( 1996 ) .
The C Programming Language ( 2nd ed . ) .
Prentice Hall .
ISBN .
== Further reading ==
Kernighan , Brian ; Ritchie , Dennis ( 1988 ) .
The C Programming Language ( 2 ed . ) .
Prentice Hall .
ISBN .
( archive ) Plauger , .
( 1992 ) .
The Standard C Library ( 1 ed . ) .
Prentice Hall .
ISBN .
( source ) Banahan , ; Brady , ; Doran , ( 1991 ) .
The C Book : Featuring the ANSI C Standard ( 2 ed . ) .
ISBN .
( free ) Harbison , Samuel ; Steele Jr , Guy ( 2002 ) .
C : A Reference Manual ( 5 ed . ) .
Pearson .
ISBN .
( archive ) King , .
( 2008 ) .
C Programming : A Modern Approach ( 2 ed . ) .
Norton .
ISBN .
( archive ) Griffiths , David ; Griffiths , Dawn ( 2012 ) .
Head First C ( 1 ed . ) .
ISBN .
Perry , Greg ; Miller , Dean ( 2013 ) .
C Programming : Absolute Beginner Guide ( 3 ed . ) .
Que .
ISBN .
Deitel , Paul ; Deitel , Harvey ( 2015 ) .
C : How to Program ( 8 ed . ) .
Pearson .
ISBN .
( archive ) Gustedt , Jens ( 2019 ) .
Modern C ( 2 ed . ) .
Manning .
ISBN .
( free ) == External links ==
ISO C Working Group official website 9899 , publicly available official C documents , including the C99 Rationale C99 with Technical corrigenda TC1 , TC2 , and TC3 included ( PDF ) .
( MB ) Frequently Asked Questions A History of C , by Dennis Ritchie
